# Mecanum TeleOp

## Mecanum Wheels

- **Unique Configuration**: Mecanum wheels have unique rollers positioned at a 45-degree angle around the wheel.
- **Holonomic Movement**: These wheels enable a robot to move in any horizontal direction without changing the wheels' or robot's orientation.
- **Vector Force**: Rotating Mecanum wheels generate a 45-degree force vector, combining to move the robot.
- **X Configuration**: The wheels are mounted to form an 'X' pattern when viewed from above, crucial for omnidirectional movement.

![Image](/assets/mecanumDirections.png)

## Mecanum Wheel Control

$$
y = \text{forward velocity} \\
x = \text{strafe velocity} \times f \\
r = \text{rotational velocity}
$$

$$
\text{denominator} = \max(\lvert y \rvert + \lvert x \rvert + \lvert r \rvert, 1) \\
\text{frontLeftMotor} = \frac{y + x + r}{\text{denominator}} \\
\text{backLeftMotor} = \frac{y - x + r}{\text{denominator}} \\
\text{frontRightMotor} = \frac{y - x - r}{\text{denominator}} \\
\text{backRightMotor} = \frac{y + x - r}{\text{denominator}}
$$

## Deriving Mecanum Wheel Control

Let break the down to understand it

$$ Motors = y $$

![Image](/assets/forward_backward.png)

Forward/Back movement is obvious, however, there are still a few things to note. Remember that joysticks have an interval of `-1 to 1`. Motors moves counterclockwise so you want to reverse the y direction: `double y = -gamepad1.left_stick_y;`

$$
\text{leftMotors} = y + r \\
\text{rightMotors} = y - r
$$

Now in our current form, we have a differential drive/tank drive, enabling differential steering.

![Image](/assets/rotation.png)

If both sticks are pushed at the same time, it will cause the robot to move in a curve

$$
\text{leftMotors} = 1 + 1 = 2 \, (\text{Clipped to } 1) \\
\text{rightMotors} = 1 - 1 = 0
$$

![Image](/assets/curve.png)

We add the final x value to enable omnidirectional movement based on the direction of the vector forces for each wheel.

$$ \text{frontLeftMotor} = y + x + r $$

<div style={{ display: "flex", justifyContent: "center" }}>
  ![Image](/assets/FL.png)
</div>

$$ \text{backLeftMotor} = y - x + r $$

![Image](/assets/BL.png)

$$ \text{frontRightMotor} = y - x - r $$

![Image](/assets/FR.png)

$$ \text{backRightMotor} = y + x - r $$

![Image](/assets/BR.png)

$$
f = \text{strafe adjustment factor} = \frac{\text{track length}}{\text{track width}}
$$

The strafe adjustment factor counteracts imperfect strafing caused by the difference between tracklength and trackwidth.

The SDK simply clips to the range `-1 to 1`. This causes us to lose the ratio between the wheel velocities, leading to deviations from the robot's intended path. The `denominator` normalizes the velocity of the wheels to ensure that all the powers maintain the same ratio when the largest powerâ€™s absolute value exceeds 1.
