import { Callout } from "nextra/components";
import { Tabs } from "nextra/components";

# TeleOp

TeleOp, the driver-controlled phase, is divided into two roles: the primary driver, responsible for movement, and the secondary driver, overseeing intake. We maintain a consistent framework for our TeleOp annually but innovate with complex algorithms and driver enhancements to achieve the **Control Award**.

# Primary Driver

The primary driver's role is to maneuver the robot. To facilitate this, the programmer should integrate driver enhancements into the TeleOp code, which will be segmented for better management.

# Precision Mode

The precision method adjusts our robot's motor speeds with a multiplier, creating a mode for enhanced control. It also scales motor values to fit the FTC SDK range of -1 to 1.

```java
protected void setMotorSpeeds(double mult, double[] powers) {
    for (int i = 0; i < 4; i++) {
        powers[i] = powers[i] * mult;
    }
    double max = Math.max(Math.max(Math.abs(powers[0]), Math.abs(powers[1])),
            Math.max(Math.abs(powers[2]), Math.abs(powers[3])));
    double scale = Math.abs(1 / max);
    // SCALES POWER TO KEEP IN RANGE LIMIT
    if (scale > 1) {
        scale = 1;
    }
    for (int i = 0; i < 4; i++) {
        powers[i] *= scale;
    }
    for (int i = 0; i < 4; i++) {
        motors[i].setPower(powers[i]);
    }
}
```

```java
// PRECISION
double mult = gamepad1.left_bumper ? 0.35 : gamepad1.right_bumper ? 0.7 : 1.0;
// DRIVE MODE
switch (driveMode) {
    case MECANUM: {
        double pivot = gamepad1.right_stick_x;
        double mX, mY;
        mX = gamepad1.left_stick_x * 1.1; // Counteract imperfect strafing
        mY = -gamepad1.left_stick_y; // This is reversed
        setMotorSpeeds(mult, new double[]{
            mY - mX - pivot,
            mY + mX - pivot,
            mY + mX + pivot,
            mY - mX + pivot});
        break;
    }
}
```

# Drive Modes

Our driver enhancements feature selectable drive modes, catering to individual preferences. While its impact is subtle, it showcases our adaptability and flexibility in drivetrain configurations to judges.

```java
// DriveMode enum
protected enum DriveMode {
    TANK, DRIVE, MECANUM, FIELDCENTRIC,
}
//Initial Drive Mode
protected DriveMode driveMode = DriveMode.FIELDCENTRIC;

public void runOpMode() throws InterruptedException {
    initHardware();
    waitForStart();
    while (opModeIsActive()) {
        // DRIVETRAIN
        if (gamepad1.dpad_left) {
            driveMode = DriveMode.TANK;
            //Rumble for driver preference
            gamepad1.rumbleBlips(1);
        } else if (gamepad1.dpad_up) {
            driveMode = DriveMode.MECANUM;
            gamepad1.rumbleBlips(2);
        } else if (gamepad1.dpad_right) {
            driveMode = DriveMode.DRIVE;
            gamepad1.rumbleBlips(3);
        } else if (gamepad1.dpad_down) {
            driveMode = DriveMode.FIELDCENTRIC;
            gamepad1.rumbleBlips(4);
        }
        // DRIVE MODE
        switch (driveMode) {
            case TANK: {
                double l = -gamepad1.left_stick_y,
                        r = -gamepad1.right_stick_y;
                setMotorSpeeds(mult, new double[]{r, r, l, l});
                break;
            }
            case DRIVE: {
                double pivot = gamepad1.left_stick_x, y = -gamepad1.left_stick_y;
                setMotorSpeeds(mult, new double[]{
                    y - pivot,
                    y - pivot,
                    y + pivot,
                    y + pivot
                });
                break;
            }
            case MECANUM: {
                double pivot = gamepad1.right_stick_x;
                double mX, mY;
                mX = gamepad1.left_stick_x * 1.1; // Counteract imperfect strafing
                mY = -gamepad1.left_stick_y; // Remember, this is reversed!
                setMotorSpeeds(mult, new double[]{
                    mY - mX - pivot,
                    mY + mX - pivot,
                    mY + mX + pivot,
                    mY - mX + pivot});
                break;
            }
            case FIELDCENTRIC: {
                double y = -gamepad1.left_stick_y; // Remember, this is reversed!
                double x = gamepad1.left_stick_x * 1.1; // Counteract imperfect strafing
                double rx = gamepad1.right_stick_x;

                double botHeading = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.RADIANS);

                // Rotate the movement direction counter to the bot's rotation
                double rotX = x * Math.cos(-botHeading) - y * Math.sin(-botHeading);
                double rotY = x * Math.sin(-botHeading) + y * Math.cos(-botHeading);
                setMotorSpeeds(mult, new double[]{
                    rotY - rotX - rx,
                    rotY + rotX - rx,
                    rotY + rotX + rx,
                    rotY - rotX + rx});
                break;
            }
        }
    }
}
```

# Field Centric

In Field Centric Drive mode, the translation joystick allows the robotâ€™s direction to be controlled relative to the field/driver rather than the robotâ€™s frame. The code uses the Control Hub IMU to rotate the robotâ€™s movement relative to its rotation. One issue with the IMU is that it can fail due to lag or other factors, so the code includes a failsafe that resets the IMU if necessary.

```java
 public void runOpMode() throws InterruptedException {
    // FIELD CENTRIC
    IMU imu = hardwareMap.get(IMU.class, "imu");
    // ADJUST ORIENTATION PARAMETERS TO MATCH THE ROBOT
    IMU.Parameters parameters = new IMU.Parameters(new RevHubOrientationOnRobot(
            RevHubOrientationOnRobot.LogoFacingDirection.FORWARD,
            RevHubOrientationOnRobot.UsbFacingDirection.UP));
    imu.initialize(parameters);
    initHardware();
    waitForStart();
    while (opModeIsActive()) {
        // IMU RESET
        if (gamepad1.y && gamepad1.back) {
            imu.resetYaw();
            //Rumble for driver preference
            gamepad1.rumbleBlips(5);
        }
        // DRIVE MODE
        switch (driveMode) {
            case FIELDCENTRIC: {
                double y = -gamepad1.left_stick_y; // Remember, this is reversed!
                double x = gamepad1.left_stick_x * 1.1; // Counteract imperfect strafing
                double rx = gamepad1.right_stick_x;

                double botHeading = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.RADIANS);

                // Rotate the movement direction counter to the bot's rotation
                double rotX = x * Math.cos(-botHeading) - y * Math.sin(-botHeading);
                double rotY = x * Math.sin(-botHeading) + y * Math.cos(-botHeading);
                setMotorSpeeds(mult, new double[]{
                    rotY - rotX - rx,
                    rotY + rotX - rx,
                    rotY + rotX + rx,
                    rotY - rotX + rx});
                break;
            }
        }
    }
 }
```

# Secondary Driver

In FTC, subsystems comprise control elements like motors, servos, and sensors. The second driver controls specific robot subsystems. While mechanisms change each season, the underlying principle remains consistent. Create a class for each mechanism and a method for each motion component.

# Claw

Develop a separate class for every mechanism and establish a method for each motion component. For example, this is the code for a claw:

<Tabs items={['BaseOpMode Class', 'Claw Class', 'Method Usage']}>
  <Tabs.Tab>
    ```java
    public abstract class BaseOpMode extends LinearOpMode {
        protected Claw claws;
        
        protected void initHardware() {
            Servo claw = hardwareMap.get(Servo.class, "servo");
            claws = new Claw(claw);
        }
    }
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```java
    public class Claw {
        private Servo claw;
        
        public Claw(Servo servo) {
            this.claw = servo;
        }

        public void clawsOpen() {
            claw.setPosition(1);
        }

        public void clawsClose() {
            claw.setPosition(0);
        }

        public double getCurrentPosition() {
            return claw.getPosition();
        }
    }
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```java
    if (gamepad2.right_bumper) {
        claws.clawsClose();
    }
    if (gamepad2.left_bumper) {
        claws.clawsOpen();
    }
    ```
  </Tabs.Tab>
</Tabs>

# Arms/Slides

Arms and slides are affected by gravity, so you will be forced to use a feedforward system. This video by KookyBotz showcases how to create and tune a feedforward system.

<iframe
  width="100%"
  height="500px"
  src="https://www.youtube.com/embed/E6H6Nqe6qJo"
  frameborder="6"
  allowfullscreen
></iframe>

# Filters

Filters enhance sensor precision and accuracy by reducing noise levels. Additionally, filters are great to mention the Control Award. There are multiple libraries that will make it easy to implement filters.

<Callout type="info" emoji="ðŸ’¡">
  Examples are taken from [CTRL ALT FTC](https://www.ctrlaltftc.com/)
</Callout>

# Low pass filter

The low pass filter is a basic algorithm that reduces noise levels by smoothing the values.

```java
double a = 0.9;
LowPassFilter filter = new LowPassFilter(a);
while (true) {
    double currentValue = readNoisySensor();
    double estimate = filter.estimate(currentValue);
}
```

# Kalman Filter

A Kalman filter at the highest level is an algorithm that optimally estimates any given state of a system

```java
double Q = 0.3;
double R = 3;
int N = 3;
KalmanFilter filter = new KalmanFilter(Q,R,N);
while (true) {
    double currentValue = readNoisySensor();
    double estimate = filter.estimate(currentValue);
}
```
