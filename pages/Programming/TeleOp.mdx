import { Callout } from "nextra/components";
import { Tabs } from "nextra/components";

# TeleOp

TeleOp, the driver-controlled phase, is divided into two roles: the primary driver, responsible for movement, and the secondary driver, overseeing intake. We maintain a consistent framework for our TeleOp annually but innovate with complex algorithms and driver enhancements to achieve the **Control Award**.

## Primary Driver

The primary driver's role is to maneuver the robot. To facilitate this, the programmer should integrate driver enhancements into the TeleOp code, which will be segmented for better management.

### Precision Mode

The precision method adjusts our robot's motor speeds with a multiplier, creating a mode for enhanced control. It also scales motor values to fit the FTC SDK range of -1 to 1.

````java
double mult = gamepad1.left_bumper ? 0.35 : gamepad1.right_bumper ? 0.7 : 1.0;
// DRIVE MODE
switch (driveMode){
    case MECANUM: {
        double pivot = gamepad1.right_stick_x;
        double mX, mY;
        mX = gamepad1.left_stick_x * 1.1; // Counteract imperfect strafing
        mY = -gamepad1.left_stick_y; // This is reversed
        setMotorSpeeds(mult, new double[]{
                mY - mX - pivot,
                mY + mX - pivot,
                mY + mX + pivot,
                mY - mX + pivot});
        break;
    }
}
...
protected void setMotorSpeeds(double mult, double[] powers) {
    for (int i = 0; i < 4; i++) {
        powers[i] = powers[i] * mult;
    }
    double max = Math.max(Math.max(Math.abs(powers[0]), Math.abs(powers[1])),
            Math.max(Math.abs(powers[2]), Math.abs(powers[3])));
    double scale = Math.abs(1 / max);
    // SCALES POWER TO KEEP IN RANGE LIMIT
    if (scale > 1) {
        scale = 1;
    }
    for (int i = 0; i < 4; i++) {
        powers[i] *= scale;
    }
    for (int i = 0; i < 4; i++) {
        motors[i].setPower(powers[i]);
    }
}
...

### Drive Modes

Our driver enhancements feature selectable drive modes, catering to individual preferences. While its impact is subtle, it showcases our adaptability and flexibility in drivetrain configurations to judges.

```java
// DriveMode enum
protected enum DriveMode {
    TANK, DRIVE, MECANUM, FIELDCENTRIC,
}
//Initial Drive Mode
protected DriveMode driveMode = DriveMode.FIELDCENTRIC;

public void runOpMode() throws InterruptedException {
    initHardware();
    waitForStart();
    while (opModeIsActive()) {
        // DRIVETRAIN
        if (gamepad1.dpad_left) {
            driveMode = DriveMode.TANK;
            //Rumble for driver preference
            gamepad1.rumbleBlips(1);
        } else if (gamepad1.dpad_up) {
            driveMode = DriveMode.MECANUM;
            gamepad1.rumbleBlips(2);
        } else if (gamepad1.dpad_right) {
            driveMode = DriveMode.DRIVE;
            gamepad1.rumbleBlips(3);
        } else if (gamepad1.dpad_down) {
            driveMode = DriveMode.FIELDCENTRIC;
            gamepad1.rumbleBlips(4);
        }
        // DRIVE MODE
        switch (driveMode) {
            case TANK: {
                double l = -gamepad1.left_stick_y,
                        r = -gamepad1.right_stick_y;
                setMotorSpeeds(mult, new double[]{r, r, l, l});
                break;
            }
            case DRIVE: {
                double pivot = gamepad1.left_stick_x, y = -gamepad1.left_stick_y;
                setMotorSpeeds(mult, new double[]{
                    y - pivot,
                    y - pivot,
                    y + pivot,
                    y + pivot
                });
                break;
            }
            case MECANUM: {
                double pivot = gamepad1.right_stick_x;
                double mX, mY;
                mX = gamepad1.left_stick_x * 1.1; // Counteract imperfect strafing
                mY = -gamepad1.left_stick_y; // Remember, this is reversed!
                setMotorSpeeds(mult, new double[]{
                    mY - mX - pivot,
                    mY + mX - pivot,
                    mY + mX + pivot,
                    mY - mX + pivot});
                break;
            }
            case FIELDCENTRIC: {
                double y = -gamepad1.left_stick_y; // Remember, this is reversed!
                double x = gamepad1.left_stick_x * 1.1; // Counteract imperfect strafing
                double rx = gamepad1.right_stick_x;

                double botHeading = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.RADIANS);

                // Rotate the movement direction counter to the bot's rotation
                double rotX = x * Math.cos(-botHeading) - y * Math.sin(-botHeading);
                double rotY = x * Math.sin(-botHeading) + y * Math.cos(-botHeading);
                setMotorSpeeds(mult, new double[]{
                    rotY - rotX - rx,
                    rotY + rotX - rx,
                    rotY + rotX + rx,
                    rotY - rotX + rx});
                break;
            }
        }
    }
}
````

### Field Centric

In Field Centric Drive mode, the translation joystick allows the robot’s direction to be controlled relative to the field/driver rather than the robot’s frame. The code uses the Control Hub IMU to rotate the robot’s movement relative to its rotation. One issue with the IMU is that it can fail due to lag or other factors, so the code includes a failsafe that resets the IMU if necessary.

```java
 public void runOpMode() throws InterruptedException {
    // FIELD CENTRIC
    IMU imu = hardwareMap.get(IMU.class, "imu");
    // ADJUST ORIENTATION PARAMETERS TO MATCH THE ROBOT
    IMU.Parameters parameters = new IMU.Parameters(new RevHubOrientationOnRobot(
            RevHubOrientationOnRobot.LogoFacingDirection.FORWARD,
            RevHubOrientationOnRobot.UsbFacingDirection.UP));
    imu.initialize(parameters);
    initHardware();
    waitForStart();
    while (opModeIsActive()) {
        // IMU RESET
        if (gamepad1.y && gamepad1.back) {
            imu.resetYaw();
            //Rumble for driver preference
            gamepad1.rumbleBlips(5);
        }
        // DRIVE MODE
        switch (driveMode) {
            case FIELDCENTRIC: {
                double y = -gamepad1.left_stick_y; // Remember, this is reversed!
                double x = gamepad1.left_stick_x * 1.1; // Counteract imperfect strafing
                double rx = gamepad1.right_stick_x;

                double botHeading = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.RADIANS);

                // Rotate the movement direction counter to the bot's rotation
                double rotX = x * Math.cos(-botHeading) - y * Math.sin(-botHeading);
                double rotY = x * Math.sin(-botHeading) + y * Math.cos(-botHeading);
                setMotorSpeeds(mult, new double[]{
                    rotY - rotX - rx,
                    rotY + rotX - rx,
                    rotY + rotX + rx,
                    rotY - rotX + rx});
                break;
            }
        }
    }
 }
```

## Secondary Driver

In FTC, subsystems comprise control elements like motors, servos, and sensors. The second driver controls specific robot subsystems. While mechanisms change each season, the underlying principle remains consistent. Create a class for each mechanism and a method for each motion component.

### Claw

Develop a separate class for every mechanism and establish a method for each motion component. For example, this is the code for a claw:

<Tabs items={['BaseOpMode Class', 'Claw Class', 'Method Usage']}>
  <Tabs.Tab>
    ```java
    public abstract class BaseOpMode extends LinearOpMode {
        protected Claw claws;
        
        protected void initHardware() {
            Servo claw = hardwareMap.get(Servo.class, "servo");
            claws = new Claw(claw);
        }
    }
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```java
    public class Claw {
        private Servo claw;
        
        public Claw(Servo servo) {
            this.claw = servo;
        }

        public void clawsOpen() {
            claw.setPosition(1);
        }

        public void clawsClose() {
            claw.setPosition(0);
        }

        public double getCurrentPosition() {
            return claw.getPosition();
        }
    }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```java
    if (gamepad2.right_bumper) {
        claws.clawsClose();
    }
    if (gamepad2.left_bumper) {
        claws.clawsOpen();
    }
    ```
  </Tabs.Tab>
</Tabs>

### Arms/Slides

Arms and slides are affected by gravity, so you will be forced to use a feedforward system.

<Tabs items={['BaseOpMode Class', 'Slides Class', 'TeleOp Example', 'PIDF Tuner']}>
  <Tabs.Tab>
    ```java
    package org.firstinspires.ftc.teamcode.Framework;

    import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
    import com.qualcomm.robotcore.hardware.DcMotor;
    import com.qualcomm.robotcore.hardware.Servo;

    public abstract class BaseOpMode extends LinearOpMode {
        // Variable Definition - Define arrays to hold motor objects and instances of Claw and Slides classes
        protected DcMotor[] motors;
        protected Claw claws;
        protected Slides slides;
        // Method to initialize hardware components in OpModes
        protected void initHardware() {
            // Motor initialization by getting them from the hardwareMap in array
            motors = new DcMotor[]{
                    hardwareMap.dcMotor.get("motor fr"),
                    hardwareMap.dcMotor.get("motor br"),
                    hardwareMap.dcMotor.get("motor fl"),
                    hardwareMap.dcMotor.get("motor bl")
            };

            // Based on the physical orientation of the motor on the robot, it sets the desired direction of the motor
            motors[0].setDirection(DcMotor.Direction.REVERSE);
            motors[1].setDirection(DcMotor.Direction.REVERSE);
            motors[2].setDirection(DcMotor.Direction.FORWARD);
            motors[3].setDirection(DcMotor.Direction.FORWARD);

            // Initialize the servo hardware
            Servo claw = hardwareMap.get(Servo.class, "servo");
            // Create a Claw object and assign in to the claws variable (From the constructor inside the Claw class)
            claws = new Claw(claw);

            // Getting references to the slide motor hardware and initializing Slides object with them
            DcMotor leftSlideMotor = hardwareMap.get(DcMotor.class, "leftSlideMotor");
            DcMotor rightSlideMotor = hardwareMap.get(DcMotor.class, "rightSlideMotor");
            slides = new Slides(leftSlideMotor, rightSlideMotor);
        }
    }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```java
    package org.firstinspires.ftc.teamcode.Framework;

    import com.ThermalEquilibrium.homeostasis.Controllers.Feedback.BasicPID;
    import com.ThermalEquilibrium.homeostasis.Parameters.PIDCoefficients;
    import com.qualcomm.robotcore.hardware.DcMotor;

    public class Slides {
        // Defining private variables to hold motor objects and constants for the PID controller
        private DcMotor leftSlideMotor;
        private DcMotor rightSlideMotor;
        private final double Kp = 0;
        private final double Ki = 0;
        private final double Kd = 0;
        private final double f = 0;
        public int targetPosition = 0;
        private final double ticksInDegree = 145.1 / 360.0;
        PIDCoefficients coefficients = new PIDCoefficients(Kp,Ki,Kd);
        BasicPID controller = new BasicPID(coefficients);
        private double power;

        // Constructor initializes the Slides object with the left and right slide motors
        public Slides(DcMotor leftSlideMotor, DcMotor rightSlideMotor) {
            this.leftSlideMotor = leftSlideMotor;
            this.rightSlideMotor = rightSlideMotor;
        }

        // Method to set the target position for the slides
        public void setTargetPosition(int targetPosition) {
            this.targetPosition = targetPosition;
        }

        // Method updates the power to the slide motors using PID control and a feed-forward term
        public void update() {
            // Gets the current position of the motor
            int currentPosition = leftSlideMotor.getCurrentPosition();
            // Calculate the PID control output based on the current and target positions
            double pid = controller.calculate(targetPosition, currentPosition);
            // Calculate the feed-forward term to anticipate gravity's effect on the slide
            double ff = Math.cos(Math.toRadians(targetPosition / ticksInDegree)) * f;
            // Determine the total power as the sum of PID output and feed-forward term
            this.power = pid + ff;
            moveSlides(power);
        }

        // Method to set the power of both slide motors
        public void moveSlides(double power) {
            leftSlideMotor.setPower(power);
            rightSlideMotor.setPower(power);
        }
        // Method to get the position of where you want the system to be
        public int getTargetPosition() {
            return this.targetPosition;
        }
    }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```java
    package org.firstinspires.ftc.teamcode;

    import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
    import org.firstinspires.ftc.teamcode.Framework.BaseOpMode;
    @TeleOp(name = "PIDTele")
    public class PIDTele extends BaseOpMode{
        @Override
        public void runOpMode() throws InterruptedException {
            initHardware();
            waitForStart();
            // Main loop for the OpMode
            while(opModeIsActive()){
                // Manuel Joystick control
                slides.setTargetPosition(slides.getTargetPosition() + (int) (gamepad2.left_stick_y * 0.5));
                // Preset positions
                if(gamepad2.a){
                    slides.setTargetPosition(0);
                }
                if(gamepad2.b){
                    slides.setTargetPosition(100);
                }
                // Updating the slide power using the PID controller inside the loop
                slides.update();
            }
        }
    }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```java
    package org.firstinspires.ftc.teamcode;

    import com.ThermalEquilibrium.homeostasis.Controllers.Feedback.BasicPID;
    import com.ThermalEquilibrium.homeostasis.Parameters.PIDCoefficients;
    import com.acmerobotics.dashboard.FtcDashboard;
    import com.acmerobotics.dashboard.config.Config;
    import com.acmerobotics.dashboard.telemetry.MultipleTelemetry;
    import com.qualcomm.robotcore.eventloop.opmode.OpMode;
    import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
    import com.qualcomm.robotcore.hardware.DcMotorEx;
    import com.qualcomm.robotcore.hardware.DcMotorSimple;

    @Config
    @TeleOp(name = "PIDF Test")
    public class PIDF_Test extends OpMode {
        // Public static variables for tuning PIDF coefficients through the dashboard
        public static double p = 0, i = 0, d = 0;
        public static double f = 0;
        public static int targetPosition = 0;

        // Conversion factor for ticks to degrees
        private final double ticksInDegree = 145.1 / 360.0;

        // Motor declarations
        private DcMotorEx slideRight, slideLeft;

        // PID coefficients object initialization
        PIDCoefficients coefficients = new PIDCoefficients(p, i, d);

        @Override
        public void init(){
            // Setting up telemetry with the FTC dashboard
            telemetry = new MultipleTelemetry(telemetry, FtcDashboard.getInstance().getTelemetry());

            // Mapping and initializing motors
            slideRight = hardwareMap.get(DcMotorEx.class, "rightSlide");
            slideLeft = hardwareMap.get(DcMotorEx.class, "leftSlide");
            slideRight.setDirection(DcMotorSimple.Direction.REVERSE);
        }

        @Override
        public void loop(){
            // Re-initializing the PID controller with the latest coefficients
            BasicPID controller = new BasicPID(coefficients);

            // Getting the current position of the right slide
            int currentPosition = slideRight.getCurrentPosition();

            // Calculating PID output using the target and current positions
            double pid = controller.calculate(targetPosition, currentPosition);

            // Calculating feed-forward term using the cosine of the target angle
            double ff = Math.cos(Math.toRadians(targetPosition / ticksInDegree)) * f;

            // Combining PID and feed-forward terms to get the total power
            double power = pid + ff;

            // Setting the motor powers with the calculated power
            slideRight.setPower(power);
            slideLeft.setPower(power);

            // Sending the current state to the telemetry
            telemetry.addData("right_pos", slideRight.getCurrentPosition());
            telemetry.addData("left_pos", slideLeft.getCurrentPosition());
            telemetry.addData("target", targetPosition);
            telemetry.update();
        }
    }
    ```

  </Tabs.Tab>
</Tabs>

## Filters

Filters enhance sensor precision and accuracy by reducing noise levels. Additionally, filters are great to mention the Control Award. There are multiple libraries that will make it easy to implement filters.

<Callout type="info" emoji="💡">
  Examples are taken from [CTRL ALT FTC](https://www.ctrlaltftc.com/)
</Callout>

### Low pass filter

The low pass filter is a basic algorithm that reduces noise levels by smoothing the values.

```java
double a = 0.9;
LowPassFilter filter = new LowPassFilter(a);
while (true) {
    double currentValue = readNoisySensor();
    double estimate = filter.estimate(currentValue);
}
```

### Kalman Filter

A Kalman filter at the highest level is an algorithm that optimally estimates any given state of a system

```java
double Q = 0.3;
double R = 3;
int N = 3;
KalmanFilter filter = new KalmanFilter(Q,R,N);
while (true) {
    double currentValue = readNoisySensor();
    double estimate = filter.estimate(currentValue);
}
```
